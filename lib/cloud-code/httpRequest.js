"use strict";

var _HTTPResponse = _interopRequireDefault(require("./HTTPResponse"));

var _querystring = _interopRequireDefault(require("querystring"));

var _logger = _interopRequireDefault(require("../logger"));

var _followRedirects = require("follow-redirects");

var _url = require("url");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const clients = {
  'http:': _followRedirects.http,
  'https:': _followRedirects.https
};

function makeCallback(resolve, reject) {
  return function (response) {
    const chunks = [];
    response.on('data', chunk => {
      chunks.push(chunk);
    });
    response.on('end', () => {
      const body = Buffer.concat(chunks);
      const httpResponse = new _HTTPResponse.default(response, body); // Consider <200 && >= 400 as errors

      if (httpResponse.status < 200 || httpResponse.status >= 400) {
        return reject(httpResponse);
      } else {
        return resolve(httpResponse);
      }
    });
    response.on('error', reject);
  };
}

const encodeBody = function ({
  body,
  headers = {}
}) {
  if (typeof body !== 'object') {
    return {
      body,
      headers
    };
  }

  var contentTypeKeys = Object.keys(headers).filter(key => {
    return key.match(/content-type/i) != null;
  });

  if (contentTypeKeys.length == 0) {
    // no content type
    //  As per https://parse.com/docs/cloudcode/guide#cloud-code-advanced-sending-a-post-request the default encoding is supposedly x-www-form-urlencoded
    body = _querystring.default.stringify(body);
    headers['Content-Type'] = 'application/x-www-form-urlencoded';
  } else {
    /* istanbul ignore next */
    if (contentTypeKeys.length > 1) {
      _logger.default.error('Parse.Cloud.httpRequest', 'multiple content-type headers are set.');
    } // There maybe many, we'll just take the 1st one


    var contentType = contentTypeKeys[0];

    if (headers[contentType].match(/application\/json/i)) {
      body = JSON.stringify(body);
    } else if (headers[contentType].match(/application\/x-www-form-urlencoded/i)) {
      body = _querystring.default.stringify(body);
    }
  }

  return {
    body,
    headers
  };
};
/**
 * Makes an HTTP Request.
 *
 * **Available in Cloud Code only.**
 *
 * By default, Parse.Cloud.httpRequest does not follow redirects caused by HTTP 3xx response codes. You can use the followRedirects option in the {@link Parse.Cloud.HTTPOptions} object to change this behavior.
 *
 * Sample request:
 * ```
 * Parse.Cloud.httpRequest({
 *   url: 'http://www.parse.com/'
 * }).then(function(httpResponse) {
 *   // success
 *   console.log(httpResponse.text);
 * },function(httpResponse) {
 *   // error
 *   console.error('Request failed with response code ' + httpResponse.status);
 * });
 * ```
 *
 * @method httpRequest
 * @name Parse.Cloud.httpRequest
 * @param {Parse.Cloud.HTTPOptions} options The Parse.Cloud.HTTPOptions object that makes the request.
 * @return {Promise<Parse.Cloud.HTTPResponse>} A promise that will be resolved with a {@link Parse.Cloud.HTTPResponse} object when the request completes.
 */


module.exports = function httpRequest(options) {
  let url;

  try {
    url = (0, _url.parse)(options.url);
  } catch (e) {
    return Promise.reject(e);
  }

  options = Object.assign(options, encodeBody(options)); // support params options

  if (typeof options.params === 'object') {
    options.qs = options.params;
  } else if (typeof options.params === 'string') {
    options.qs = _querystring.default.parse(options.params);
  }

  const client = clients[url.protocol];

  if (!client) {
    return Promise.reject(`Unsupported protocol ${url.protocol}`);
  }

  const requestOptions = {
    method: options.method,
    port: Number(url.port),
    path: url.pathname,
    hostname: url.hostname,
    headers: options.headers,
    encoding: null,
    followRedirects: options.followRedirects === true
  };

  if (requestOptions.headers) {
    Object.keys(requestOptions.headers).forEach(key => {
      if (typeof requestOptions.headers[key] === 'undefined') {
        delete requestOptions.headers[key];
      }
    });
  }

  if (url.search) {
    options.qs = Object.assign({}, options.qs, _querystring.default.parse(url.query));
  }

  if (url.auth) {
    requestOptions.auth = url.auth;
  }

  if (options.qs) {
    requestOptions.path += `?${_querystring.default.stringify(options.qs)}`;
  }

  if (options.agent) {
    requestOptions.agent = options.agent;
  }

  return new Promise((resolve, reject) => {
    const req = client.request(requestOptions, makeCallback(resolve, reject, options));

    if (options.body) {
      req.write(options.body);
    }

    req.on('error', error => {
      reject(error);
    });
    req.end();
  });
};
/**
 * @typedef Parse.Cloud.HTTPOptions
 * @property {String|Object} body The body of the request. If it is a JSON object, then the Content-Type set in the headers must be application/x-www-form-urlencoded or application/json. You can also set this to a {@link Buffer} object to send raw bytes. If you use a Buffer, you should also set the Content-Type header explicitly to describe what these bytes represent.
 * @property {function} error The function that is called when the request fails. It will be passed a Parse.Cloud.HTTPResponse object.
 * @property {Boolean} followRedirects Whether to follow redirects caused by HTTP 3xx responses. Defaults to false.
 * @property {Object} headers The headers for the request.
 * @property {String} method The method of the request. GET, POST, PUT, DELETE, HEAD, and OPTIONS are supported. Will default to GET if not specified.
 * @property {String|Object} params The query portion of the url. You can pass a JSON object of key value pairs like params: {q : 'Sean Plott'} or a raw string like params:q=Sean Plott.
 * @property {function} success The function that is called when the request successfully completes. It will be passed a Parse.Cloud.HTTPResponse object.
 * @property {string} url The url to send the request to.
 */


module.exports.encodeBody = encodeBody;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJjbGllbnRzIiwiaHR0cCIsImh0dHBzIiwibWFrZUNhbGxiYWNrIiwicmVzb2x2ZSIsInJlamVjdCIsInJlc3BvbnNlIiwiY2h1bmtzIiwib24iLCJjaHVuayIsInB1c2giLCJib2R5IiwiQnVmZmVyIiwiY29uY2F0IiwiaHR0cFJlc3BvbnNlIiwiSFRUUFJlc3BvbnNlIiwic3RhdHVzIiwiZW5jb2RlQm9keSIsImhlYWRlcnMiLCJjb250ZW50VHlwZUtleXMiLCJPYmplY3QiLCJrZXlzIiwiZmlsdGVyIiwia2V5IiwibWF0Y2giLCJsZW5ndGgiLCJxdWVyeXN0cmluZyIsInN0cmluZ2lmeSIsImxvZyIsImVycm9yIiwiY29udGVudFR5cGUiLCJKU09OIiwibW9kdWxlIiwiZXhwb3J0cyIsImh0dHBSZXF1ZXN0Iiwib3B0aW9ucyIsInVybCIsInBhcnNlIiwiZSIsIlByb21pc2UiLCJhc3NpZ24iLCJwYXJhbXMiLCJxcyIsImNsaWVudCIsInByb3RvY29sIiwicmVxdWVzdE9wdGlvbnMiLCJtZXRob2QiLCJwb3J0IiwiTnVtYmVyIiwicGF0aCIsInBhdGhuYW1lIiwiaG9zdG5hbWUiLCJlbmNvZGluZyIsImZvbGxvd1JlZGlyZWN0cyIsImZvckVhY2giLCJzZWFyY2giLCJxdWVyeSIsImF1dGgiLCJhZ2VudCIsInJlcSIsInJlcXVlc3QiLCJ3cml0ZSIsImVuZCJdLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9jbG91ZC1jb2RlL2h0dHBSZXF1ZXN0LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBIVFRQUmVzcG9uc2UgZnJvbSAnLi9IVFRQUmVzcG9uc2UnO1xuaW1wb3J0IHF1ZXJ5c3RyaW5nIGZyb20gJ3F1ZXJ5c3RyaW5nJztcbmltcG9ydCBsb2cgZnJvbSAnLi4vbG9nZ2VyJztcbmltcG9ydCB7IGh0dHAsIGh0dHBzIH0gZnJvbSAnZm9sbG93LXJlZGlyZWN0cyc7XG5pbXBvcnQgeyBwYXJzZSB9IGZyb20gJ3VybCc7XG5cbmNvbnN0IGNsaWVudHMgPSB7XG4gICdodHRwOic6IGh0dHAsXG4gICdodHRwczonOiBodHRwcyxcbn07XG5cbmZ1bmN0aW9uIG1ha2VDYWxsYmFjayhyZXNvbHZlLCByZWplY3QpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgIGNvbnN0IGNodW5rcyA9IFtdO1xuICAgIHJlc3BvbnNlLm9uKCdkYXRhJywgY2h1bmsgPT4ge1xuICAgICAgY2h1bmtzLnB1c2goY2h1bmspO1xuICAgIH0pO1xuICAgIHJlc3BvbnNlLm9uKCdlbmQnLCAoKSA9PiB7XG4gICAgICBjb25zdCBib2R5ID0gQnVmZmVyLmNvbmNhdChjaHVua3MpO1xuICAgICAgY29uc3QgaHR0cFJlc3BvbnNlID0gbmV3IEhUVFBSZXNwb25zZShyZXNwb25zZSwgYm9keSk7XG5cbiAgICAgIC8vIENvbnNpZGVyIDwyMDAgJiYgPj0gNDAwIGFzIGVycm9yc1xuICAgICAgaWYgKGh0dHBSZXNwb25zZS5zdGF0dXMgPCAyMDAgfHwgaHR0cFJlc3BvbnNlLnN0YXR1cyA+PSA0MDApIHtcbiAgICAgICAgcmV0dXJuIHJlamVjdChodHRwUmVzcG9uc2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHJlc29sdmUoaHR0cFJlc3BvbnNlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXNwb25zZS5vbignZXJyb3InLCByZWplY3QpO1xuICB9O1xufVxuXG5jb25zdCBlbmNvZGVCb2R5ID0gZnVuY3Rpb24gKHsgYm9keSwgaGVhZGVycyA9IHt9IH0pIHtcbiAgaWYgKHR5cGVvZiBib2R5ICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiB7IGJvZHksIGhlYWRlcnMgfTtcbiAgfVxuICB2YXIgY29udGVudFR5cGVLZXlzID0gT2JqZWN0LmtleXMoaGVhZGVycykuZmlsdGVyKGtleSA9PiB7XG4gICAgcmV0dXJuIGtleS5tYXRjaCgvY29udGVudC10eXBlL2kpICE9IG51bGw7XG4gIH0pO1xuXG4gIGlmIChjb250ZW50VHlwZUtleXMubGVuZ3RoID09IDApIHtcbiAgICAvLyBubyBjb250ZW50IHR5cGVcbiAgICAvLyAgQXMgcGVyIGh0dHBzOi8vcGFyc2UuY29tL2RvY3MvY2xvdWRjb2RlL2d1aWRlI2Nsb3VkLWNvZGUtYWR2YW5jZWQtc2VuZGluZy1hLXBvc3QtcmVxdWVzdCB0aGUgZGVmYXVsdCBlbmNvZGluZyBpcyBzdXBwb3NlZGx5IHgtd3d3LWZvcm0tdXJsZW5jb2RlZFxuXG4gICAgYm9keSA9IHF1ZXJ5c3RyaW5nLnN0cmluZ2lmeShib2R5KTtcbiAgICBoZWFkZXJzWydDb250ZW50LVR5cGUnXSA9ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnO1xuICB9IGVsc2Uge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgaWYgKGNvbnRlbnRUeXBlS2V5cy5sZW5ndGggPiAxKSB7XG4gICAgICBsb2cuZXJyb3IoJ1BhcnNlLkNsb3VkLmh0dHBSZXF1ZXN0JywgJ211bHRpcGxlIGNvbnRlbnQtdHlwZSBoZWFkZXJzIGFyZSBzZXQuJyk7XG4gICAgfVxuICAgIC8vIFRoZXJlIG1heWJlIG1hbnksIHdlJ2xsIGp1c3QgdGFrZSB0aGUgMXN0IG9uZVxuICAgIHZhciBjb250ZW50VHlwZSA9IGNvbnRlbnRUeXBlS2V5c1swXTtcbiAgICBpZiAoaGVhZGVyc1tjb250ZW50VHlwZV0ubWF0Y2goL2FwcGxpY2F0aW9uXFwvanNvbi9pKSkge1xuICAgICAgYm9keSA9IEpTT04uc3RyaW5naWZ5KGJvZHkpO1xuICAgIH0gZWxzZSBpZiAoaGVhZGVyc1tjb250ZW50VHlwZV0ubWF0Y2goL2FwcGxpY2F0aW9uXFwveC13d3ctZm9ybS11cmxlbmNvZGVkL2kpKSB7XG4gICAgICBib2R5ID0gcXVlcnlzdHJpbmcuc3RyaW5naWZ5KGJvZHkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4geyBib2R5LCBoZWFkZXJzIH07XG59O1xuXG4vKipcbiAqIE1ha2VzIGFuIEhUVFAgUmVxdWVzdC5cbiAqXG4gKiAqKkF2YWlsYWJsZSBpbiBDbG91ZCBDb2RlIG9ubHkuKipcbiAqXG4gKiBCeSBkZWZhdWx0LCBQYXJzZS5DbG91ZC5odHRwUmVxdWVzdCBkb2VzIG5vdCBmb2xsb3cgcmVkaXJlY3RzIGNhdXNlZCBieSBIVFRQIDN4eCByZXNwb25zZSBjb2Rlcy4gWW91IGNhbiB1c2UgdGhlIGZvbGxvd1JlZGlyZWN0cyBvcHRpb24gaW4gdGhlIHtAbGluayBQYXJzZS5DbG91ZC5IVFRQT3B0aW9uc30gb2JqZWN0IHRvIGNoYW5nZSB0aGlzIGJlaGF2aW9yLlxuICpcbiAqIFNhbXBsZSByZXF1ZXN0OlxuICogYGBgXG4gKiBQYXJzZS5DbG91ZC5odHRwUmVxdWVzdCh7XG4gKiAgIHVybDogJ2h0dHA6Ly93d3cucGFyc2UuY29tLydcbiAqIH0pLnRoZW4oZnVuY3Rpb24oaHR0cFJlc3BvbnNlKSB7XG4gKiAgIC8vIHN1Y2Nlc3NcbiAqICAgY29uc29sZS5sb2coaHR0cFJlc3BvbnNlLnRleHQpO1xuICogfSxmdW5jdGlvbihodHRwUmVzcG9uc2UpIHtcbiAqICAgLy8gZXJyb3JcbiAqICAgY29uc29sZS5lcnJvcignUmVxdWVzdCBmYWlsZWQgd2l0aCByZXNwb25zZSBjb2RlICcgKyBodHRwUmVzcG9uc2Uuc3RhdHVzKTtcbiAqIH0pO1xuICogYGBgXG4gKlxuICogQG1ldGhvZCBodHRwUmVxdWVzdFxuICogQG5hbWUgUGFyc2UuQ2xvdWQuaHR0cFJlcXVlc3RcbiAqIEBwYXJhbSB7UGFyc2UuQ2xvdWQuSFRUUE9wdGlvbnN9IG9wdGlvbnMgVGhlIFBhcnNlLkNsb3VkLkhUVFBPcHRpb25zIG9iamVjdCB0aGF0IG1ha2VzIHRoZSByZXF1ZXN0LlxuICogQHJldHVybiB7UHJvbWlzZTxQYXJzZS5DbG91ZC5IVFRQUmVzcG9uc2U+fSBBIHByb21pc2UgdGhhdCB3aWxsIGJlIHJlc29sdmVkIHdpdGggYSB7QGxpbmsgUGFyc2UuQ2xvdWQuSFRUUFJlc3BvbnNlfSBvYmplY3Qgd2hlbiB0aGUgcmVxdWVzdCBjb21wbGV0ZXMuXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaHR0cFJlcXVlc3Qob3B0aW9ucykge1xuICBsZXQgdXJsO1xuICB0cnkge1xuICAgIHVybCA9IHBhcnNlKG9wdGlvbnMudXJsKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlKTtcbiAgfVxuICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbihvcHRpb25zLCBlbmNvZGVCb2R5KG9wdGlvbnMpKTtcbiAgLy8gc3VwcG9ydCBwYXJhbXMgb3B0aW9uc1xuICBpZiAodHlwZW9mIG9wdGlvbnMucGFyYW1zID09PSAnb2JqZWN0Jykge1xuICAgIG9wdGlvbnMucXMgPSBvcHRpb25zLnBhcmFtcztcbiAgfSBlbHNlIGlmICh0eXBlb2Ygb3B0aW9ucy5wYXJhbXMgPT09ICdzdHJpbmcnKSB7XG4gICAgb3B0aW9ucy5xcyA9IHF1ZXJ5c3RyaW5nLnBhcnNlKG9wdGlvbnMucGFyYW1zKTtcbiAgfVxuICBjb25zdCBjbGllbnQgPSBjbGllbnRzW3VybC5wcm90b2NvbF07XG4gIGlmICghY2xpZW50KSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGBVbnN1cHBvcnRlZCBwcm90b2NvbCAke3VybC5wcm90b2NvbH1gKTtcbiAgfVxuICBjb25zdCByZXF1ZXN0T3B0aW9ucyA9IHtcbiAgICBtZXRob2Q6IG9wdGlvbnMubWV0aG9kLFxuICAgIHBvcnQ6IE51bWJlcih1cmwucG9ydCksXG4gICAgcGF0aDogdXJsLnBhdGhuYW1lLFxuICAgIGhvc3RuYW1lOiB1cmwuaG9zdG5hbWUsXG4gICAgaGVhZGVyczogb3B0aW9ucy5oZWFkZXJzLFxuICAgIGVuY29kaW5nOiBudWxsLFxuICAgIGZvbGxvd1JlZGlyZWN0czogb3B0aW9ucy5mb2xsb3dSZWRpcmVjdHMgPT09IHRydWUsXG4gIH07XG4gIGlmIChyZXF1ZXN0T3B0aW9ucy5oZWFkZXJzKSB7XG4gICAgT2JqZWN0LmtleXMocmVxdWVzdE9wdGlvbnMuaGVhZGVycykuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgaWYgKHR5cGVvZiByZXF1ZXN0T3B0aW9ucy5oZWFkZXJzW2tleV0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGRlbGV0ZSByZXF1ZXN0T3B0aW9ucy5oZWFkZXJzW2tleV07XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgaWYgKHVybC5zZWFyY2gpIHtcbiAgICBvcHRpb25zLnFzID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucy5xcywgcXVlcnlzdHJpbmcucGFyc2UodXJsLnF1ZXJ5KSk7XG4gIH1cbiAgaWYgKHVybC5hdXRoKSB7XG4gICAgcmVxdWVzdE9wdGlvbnMuYXV0aCA9IHVybC5hdXRoO1xuICB9XG4gIGlmIChvcHRpb25zLnFzKSB7XG4gICAgcmVxdWVzdE9wdGlvbnMucGF0aCArPSBgPyR7cXVlcnlzdHJpbmcuc3RyaW5naWZ5KG9wdGlvbnMucXMpfWA7XG4gIH1cbiAgaWYgKG9wdGlvbnMuYWdlbnQpIHtcbiAgICByZXF1ZXN0T3B0aW9ucy5hZ2VudCA9IG9wdGlvbnMuYWdlbnQ7XG4gIH1cbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBjb25zdCByZXEgPSBjbGllbnQucmVxdWVzdChyZXF1ZXN0T3B0aW9ucywgbWFrZUNhbGxiYWNrKHJlc29sdmUsIHJlamVjdCwgb3B0aW9ucykpO1xuICAgIGlmIChvcHRpb25zLmJvZHkpIHtcbiAgICAgIHJlcS53cml0ZShvcHRpb25zLmJvZHkpO1xuICAgIH1cbiAgICByZXEub24oJ2Vycm9yJywgZXJyb3IgPT4ge1xuICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICB9KTtcbiAgICByZXEuZW5kKCk7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBAdHlwZWRlZiBQYXJzZS5DbG91ZC5IVFRQT3B0aW9uc1xuICogQHByb3BlcnR5IHtTdHJpbmd8T2JqZWN0fSBib2R5IFRoZSBib2R5IG9mIHRoZSByZXF1ZXN0LiBJZiBpdCBpcyBhIEpTT04gb2JqZWN0LCB0aGVuIHRoZSBDb250ZW50LVR5cGUgc2V0IGluIHRoZSBoZWFkZXJzIG11c3QgYmUgYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkIG9yIGFwcGxpY2F0aW9uL2pzb24uIFlvdSBjYW4gYWxzbyBzZXQgdGhpcyB0byBhIHtAbGluayBCdWZmZXJ9IG9iamVjdCB0byBzZW5kIHJhdyBieXRlcy4gSWYgeW91IHVzZSBhIEJ1ZmZlciwgeW91IHNob3VsZCBhbHNvIHNldCB0aGUgQ29udGVudC1UeXBlIGhlYWRlciBleHBsaWNpdGx5IHRvIGRlc2NyaWJlIHdoYXQgdGhlc2UgYnl0ZXMgcmVwcmVzZW50LlxuICogQHByb3BlcnR5IHtmdW5jdGlvbn0gZXJyb3IgVGhlIGZ1bmN0aW9uIHRoYXQgaXMgY2FsbGVkIHdoZW4gdGhlIHJlcXVlc3QgZmFpbHMuIEl0IHdpbGwgYmUgcGFzc2VkIGEgUGFyc2UuQ2xvdWQuSFRUUFJlc3BvbnNlIG9iamVjdC5cbiAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gZm9sbG93UmVkaXJlY3RzIFdoZXRoZXIgdG8gZm9sbG93IHJlZGlyZWN0cyBjYXVzZWQgYnkgSFRUUCAzeHggcmVzcG9uc2VzLiBEZWZhdWx0cyB0byBmYWxzZS5cbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBoZWFkZXJzIFRoZSBoZWFkZXJzIGZvciB0aGUgcmVxdWVzdC5cbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBtZXRob2QgVGhlIG1ldGhvZCBvZiB0aGUgcmVxdWVzdC4gR0VULCBQT1NULCBQVVQsIERFTEVURSwgSEVBRCwgYW5kIE9QVElPTlMgYXJlIHN1cHBvcnRlZC4gV2lsbCBkZWZhdWx0IHRvIEdFVCBpZiBub3Qgc3BlY2lmaWVkLlxuICogQHByb3BlcnR5IHtTdHJpbmd8T2JqZWN0fSBwYXJhbXMgVGhlIHF1ZXJ5IHBvcnRpb24gb2YgdGhlIHVybC4gWW91IGNhbiBwYXNzIGEgSlNPTiBvYmplY3Qgb2Yga2V5IHZhbHVlIHBhaXJzIGxpa2UgcGFyYW1zOiB7cSA6ICdTZWFuIFBsb3R0J30gb3IgYSByYXcgc3RyaW5nIGxpa2UgcGFyYW1zOnE9U2VhbiBQbG90dC5cbiAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb259IHN1Y2Nlc3MgVGhlIGZ1bmN0aW9uIHRoYXQgaXMgY2FsbGVkIHdoZW4gdGhlIHJlcXVlc3Qgc3VjY2Vzc2Z1bGx5IGNvbXBsZXRlcy4gSXQgd2lsbCBiZSBwYXNzZWQgYSBQYXJzZS5DbG91ZC5IVFRQUmVzcG9uc2Ugb2JqZWN0LlxuICogQHByb3BlcnR5IHtzdHJpbmd9IHVybCBUaGUgdXJsIHRvIHNlbmQgdGhlIHJlcXVlc3QgdG8uXG4gKi9cblxubW9kdWxlLmV4cG9ydHMuZW5jb2RlQm9keSA9IGVuY29kZUJvZHk7XG4iXSwibWFwcGluZ3MiOiI7O0FBQUE7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7Ozs7QUFFQSxNQUFNQSxPQUFPLEdBQUc7RUFDZCxTQUFTQyxxQkFESztFQUVkLFVBQVVDO0FBRkksQ0FBaEI7O0FBS0EsU0FBU0MsWUFBVCxDQUFzQkMsT0FBdEIsRUFBK0JDLE1BQS9CLEVBQXVDO0VBQ3JDLE9BQU8sVUFBVUMsUUFBVixFQUFvQjtJQUN6QixNQUFNQyxNQUFNLEdBQUcsRUFBZjtJQUNBRCxRQUFRLENBQUNFLEVBQVQsQ0FBWSxNQUFaLEVBQW9CQyxLQUFLLElBQUk7TUFDM0JGLE1BQU0sQ0FBQ0csSUFBUCxDQUFZRCxLQUFaO0lBQ0QsQ0FGRDtJQUdBSCxRQUFRLENBQUNFLEVBQVQsQ0FBWSxLQUFaLEVBQW1CLE1BQU07TUFDdkIsTUFBTUcsSUFBSSxHQUFHQyxNQUFNLENBQUNDLE1BQVAsQ0FBY04sTUFBZCxDQUFiO01BQ0EsTUFBTU8sWUFBWSxHQUFHLElBQUlDLHFCQUFKLENBQWlCVCxRQUFqQixFQUEyQkssSUFBM0IsQ0FBckIsQ0FGdUIsQ0FJdkI7O01BQ0EsSUFBSUcsWUFBWSxDQUFDRSxNQUFiLEdBQXNCLEdBQXRCLElBQTZCRixZQUFZLENBQUNFLE1BQWIsSUFBdUIsR0FBeEQsRUFBNkQ7UUFDM0QsT0FBT1gsTUFBTSxDQUFDUyxZQUFELENBQWI7TUFDRCxDQUZELE1BRU87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